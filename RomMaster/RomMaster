#!/bin/bash
# shellcheck disable=2069

# RomMaster
# https://github.com/travis134/RomMaster
# Description : main script
#

#
# Environment settings
#
export TERM=linux
sudo_prefix="sudo"
# check whether sudo is needed
if [[ "${EUID}" = 0 ]]; then
    sudo_prefix=""
fi
${sudo_prefix} chmod 666 /dev/tty1
${sudo_prefix} chmod 666 /dev/uinput
shopt -s extglob # required for extented pattern recognition

#####################
#  GLOBAL VARIABLES #
#####################
base_cache=""
base_path=""
base_ext=""
base_query=""
systems=""

log() {
    local message
    local ts

    message=$1
    ts=$(date +"%Y-%m-%dT%H:%M:%S%z")

    echo "${ts}: ${message}" >&2
}

human_readable() {
    local i=${1:-0} d="" s=0 S=("Bytes" "KiB" "MiB" "GiB" "TiB" "PiB" "EiB" "YiB" "ZiB")
    while ((i > 1024 && s < ${#S[@]} - 1)); do
        printf -v d ".%02d" $((i % 1024 * 100 / 1024))
        i=$((i / 1024))
        s=$((s + 1))
    done
    echo "${i}${d} ${S[${s}]}"
}

urldecode() {
    : "${*//+/ }"
    echo -e "${_//%/\\x}"
}

# Reads config JSON in which contains information about supported systems, the
# expected extensions for suitable roms, and query overrides for better search
# results.
read_config() {
    local config

    config=$(cat config.json)

    echo "${config}"
}

# Reads a JSON array item by index. Mostly used with dialogs for mapping choice
# indices back to data.
get_by_index() {
    local elements
    local desired_index
    local desired

    elements=$1
    desired_index=$2

    desired=$(
        echo "${elements}" |
            jq --arg desired_index "${desired_index}" .["${desired_index}"]
    )

    echo "${desired}"
}

# Creates a query string for eliminating results for all systems except for
# the system desired.
create_query() {
    local systems
    local desired
    local query

    systems=$1
    desired=$2

    query=${base_query}
    query+=" "
    query+=$(
        echo "${desired}" |
            jq -r '.query'
    )

    # We need to URL encode the special characters using jq.
    echo -n "${query}" |
        jq -sRr @uri
}

# Searches for items that are compatible with a given system.
search_system() {
    local systems
    local desired
    local name
    local query
    local sort
    local projection
    local search_url
    local response
    local results
    local results_count

    systems=$1
    desired=$2

    name=$(echo "${desired}" |
        jq -r .name)

    log "Searching items for system: ${name}"

    query=$(create_query "${systems}" "${desired}")
    sort="downloads+desc"
    projection="identifier,title"
    search_url="https://archive.org/advancedsearch.php?output=json&q=${query}&fl[]=${projection}&sort[]=${sort}"

    log "Searching with url: ${search_url}"

    # Response body is JSON data formatted as:
    # {
    #   "response": {
    #     "docs": [
    #       {
    #         "identifier": "foo",
    #         "title": "bar"
    #       },
    #       ...
    #     ],
    #     ...
    #   },
    #   ...
    # }
    #
    response=$(curl -s "${search_url}")
    results=$(
        echo "${response}" |
            jq .response.docs
    )
    results_count=$(
        echo "${results}" |
            jq '. | length'
    )
    log "Found ${results_count} matching items for ${name}"

    echo "${results}"
}

# Lists files within a given item.
list_files() {
    local system
    local item
    local ext
    local all_ext
    local item_id
    local metadata_url
    local response
    local results
    local results_count

    system=$1
    item=$2

    ext=$(
        echo "${system}" |
            jq -r .ext
    )
    all_ext="${base_ext} ${ext}"
    all_ext="${all_ext} ${all_ext^^}"
    item_id=$(
        echo "${item}" |
            jq -r .identifier
    )

    metadata_url="https://archive.org/metadata/${item_id}"

    log "Loading metadata with url: ${metadata_url}"

    # Response body is JSON data formatted as:
    # {
    #   "files": [
    #     {
    #       "name": "foo",
    #       "size": "bar",
    #       ...
    #     },
    #   ...
    #   ],
    #   ...
    # }
    response=$(curl -s "${metadata_url}")
    results=$(
        echo "${response}" |
            jq -r --arg all_ext "${all_ext}" '.files
            | map(
                select(.name | split(".")[-1] | inside($all_ext))
                | {name: .name | @uri, size: .size})'
    )
    results_count=$(
        echo "${results}" |
            jq '. | length'
    )
    log "Found ${results_count} matching files in ${item_id}"

    echo "${results}"
}

# Lists files within a given archive.
list_sub_files() {
    local system
    local item
    local file
    local system_id
    local file_name
    local file_name_readable
    local ext
    local all_ext
    local item_id
    local item_name
    local sub_files_url
    local response
    local sub_file_lines
    local sub_file_names
    local sub_files_names_cache_path
    local sub_files_names_cache
    local sub_file_sizes
    local sub_files_sizes_cache_path
    local sub_files_sizes_cache
    local results
    local results_count

    system=$1
    item=$2
    file=$3

    system_id=$(
        echo "${system}" |
            jq -r .id
    )

    file_name=$(
        echo "${file}" |
            jq -r .name
    )
    file_name_readable=$(urldecode "${file_name}")
    ext=$(
        echo "${system}" |
            jq -r .ext
    )
    all_ext="${base_ext} ${ext}"
    all_ext="${all_ext} ${all_ext^^}"
    item_id=$(
        echo "${item}" |
            jq -r .identifier
    )
    item_name=$(
        echo "${item}" |
            jq -r .title
    )

    sub_files_url="https://archive.org/download/${item_id}/${file_name}/"

    log "Loading sub files with url: ${sub_files_url}"

    # Response body is HTML data formatted as:
    # ...
    # <tr><td><a href="foo">bar</a><td><td>baz<td id="size">qux</tr>
    # ...
    response=$(curl -s -L "${sub_files_url}")
    sub_file_lines=$(
        echo "${response}" |
            grep "archive.org/download/${item_id}/${file_name}/"
    )
    if [ -z "${sub_file_lines}" ]; then
        sub_file_lines=$(
            echo "${response}" |
                grep "archive.org/download/${item_id}/${file_name_readable}/"
        )
    fi
    sub_file_names=$(
        echo "${sub_file_lines}" |
            sed -nr 's/.*href="([^"]+)".*/\1/p' |
            jq --raw-input --slurp --arg item_id "${item_id}" 'split("\n")
            | .[0:-1]
            | map(sub("//archive.org/download/\($item_id)/";""))'
    )
    sub_files_names_cache_path="${base_cache}/${system_id}/${item_id}/${file_name_readable}"
    sub_files_names_cache="${sub_files_names_cache_path}/file_names.json"
    mkdir -p "${items_cache_path}"
    echo "${sub_file_names}" >"${sub_files_names_cache}"
    sub_file_sizes=$(
        echo "${sub_file_lines}" |
            sed -nr 's/.*size">([0-9]+).*/\1/p' |
            jq --raw-input --slurp 'split("\n")
            | .[0:-1]'
    )
    sub_files_sizes_cache_path="${base_cache}/${system_id}/${item_id}/${file_name_readable}"
    sub_files_sizes_cache="${sub_files_sizes_cache_path}/file_sizes.json"
    mkdir -p "${items_cache_path}"
    echo "${sub_file_sizes}" >"${sub_files_sizes_cache}"
    results=$(
        jq -n \
            --argfile sub_file_names "${sub_files_names_cache}" \
            --argfile sub_file_sizes "${sub_files_sizes_cache}" \
            --arg all_ext "${all_ext}" \
            '[$sub_file_names, $sub_file_sizes]
            | transpose 
            | map({name: .[0], size: .[1]})'
    )
    results_count=$(
        echo "${results}" |
            jq '. | length'
    )
    log "Found ${results_count} matching sub files in ${file_name}"

    echo "${results}"
}

# Download a given file to its corresponding system folder.
download_file() {
    local item
    local file
    local download_path
    local item_id
    local file_name
    local download_url
    local char
    local keep
    local progress

    item=$1
    file=$2
    download_path=$3

    item_id=$(
        echo "${item}" |
            jq -r .identifier
    )
    file_name=$(
        echo "${file}" |
            jq -r .name
    )
    download_url="https://archive.org/download/${item_id}/${file_name}"

    log "Downloading ${file_name} to ${download_path} from ${download_url}"

    curl -L -# --create-dirs -o "${download_path}" "${download_url}" 2>&1 | while IFS= read -r -n 1 char; do
        [[ ${char} =~ [0-9] ]] && keep=1
        [[ ${char} == % ]] && echo "${progress%.*}" && progress="" && keep=0
        [[ ${keep} == 1 ]] && progress="${progress}${char}"
    done
}

install_dependencies() {
    local dependencies

    #Checking required modules (RetroOZ uses odroid)
    if id "ark" &>/dev/null || id "odroid" &>/dev/null; then
        dependencies=()

        if ! dpkg -s "dialog" &>/dev/null; then
            dependencies+=("dialog")
        fi
        if ! dpkg -s "curl" &>/dev/null; then
            dependencies+=("curl")
        fi
        if ! dpkg -s "jq" &>/dev/null; then
            dependencies+=("jq")
        fi
        if ((${#dependencies[@]})); then
            dialog --clear
            dialog --infobox "Installing dependencies, please wait..." 5 50 2>&1 >/dev/tty1
            ${sudo_prefix} apt update && ${sudo_prefix} apt install -y "${dependencies[@]}" --no-install-recommends
        fi
    fi
}

start() {
    local param_device
    local status
    local config

    log "Starting RomMaster"

    #
    # Load Controls management
    #
    if [[ -e "/dev/input/by-path/platform-ff300000.usb-usb-0:1.2:1.0-event-joystick" ]]; then
        param_device="anbernic"
    elif [[ -e "/dev/input/by-path/platform-singleadc-joypad-event-joystick" ]]; then
        param_device="rg552"
    elif [[ -e "/dev/input/by-path/platform-odroidgo2-joypad-event-joystick" ]]; then
        param_device="oga"
    elif [[ -e "/dev/input/by-path/platform-odroidgo3-joypad-event-joystick" ]]; then
        param_device="ogs"
    elif [[ -e "/dev/input/by-path/platform-gameforce-gamepad-event-joystick" ]]; then
        param_device="chi"
    else
        dialog --clear --backtitle "RomMaster - System" --msgbox "Controls can't be loaded, device not recognised. Please report for additional support." 2>&1 >/dev/tty1
        exit 1
    fi
    #launch joypad
    ${sudo_prefix} ./tm-joypad RomMaster "${param_device}" >/dev/null 2>&1 &

    dialog --clear
    dialog --infobox "Initializing, please wait..." 5 50 2>&1 >/dev/tty1

    #Checking internet access
    status=$(${sudo_prefix} ping -c 1 google.com &>/dev/null)
    if [[ ${status} -ne 0 ]]; then
        dialog --clear --backtitle "RomMaster - System" --msgbox "You appear to be offline, RomMaster require an internet access to run" 10 50 2>&1 >/dev/tty1
        exit 1
    fi

    log "Installing dependencies"
    install_dependencies

    log "Reading config"
    config=$(read_config)
    base_cache=$(
        echo "${config}" |
            jq -r .cache
    )
    base_ext=$(
        echo "${config}" |
            jq -r .ext
    )
    base_path=$(
        echo "${config}" |
            jq -r .path
    )
    base_query=$(
        echo "${config}" |
            jq -r .query
    )
    systems=$(
        echo "${config}" |
            jq .systems
    )

    log "Creating cache directory"
    mkdir -p "${base_cache}"

    main_menu
}

main_menu() {
    local cmd
    local options
    local desired_index
    local status

    log "Showing Main Menu"

    cmd=(dialog --no-cancel --backtitle "RomMaster" --title " [ Main Menu ] " --menu "D-pad to move, A for <enter>, B for <space>:" "15" "50" "15")
    options=(
        0 "Find ROMs"
        1 "Clear cache"
        2 "Exit"
    )

    desired_index=$("${cmd[@]}" "${options[@]}" 2>&1 >/dev/tty1)
    status=$?
    log "Status: ${status}, Desired index: ${desired_index}"

    case ${status} in
    0)
        case ${desired_index} in
        0) systems_menu ;;
        1)
            log "Clearing cache: ${base_cache}"
            rm -rf "${base_cache}"
            mkdir -p "${base_cache}"
            dialog --backtitle "RomMaster" --msgbox "Cache cleared" 7 50 2>&1 >/dev/tty1
            main_menu
            ;;
        *) exit 0 ;;
        esac
        ;;
    *) exit 1 ;;
    esac
}

systems_menu() {
    local cmd
    local options
    local system_options
    local index
    local system_option
    local desired_index
    local status
    local desired

    log "Selected: Find ROMs"

    cmd=(dialog --cancel-label "Back" --backtitle "Pick a system" --title " [ Systems Menu ] " --menu "D-pad to move, A or B to select" "15" "50" "15")
    options=()

    system_options=$(
        echo "${systems}" |
            jq -r .[].name
    )
    index=0
    while read -r system_option; do
        options+=($((index++)) "${system_option}")
    done <<<"${system_options}"

    desired_index=$("${cmd[@]}" "${options[@]}" 2>&1 >/dev/tty1)
    status=$?
    log "Status: ${status}, Desired index: ${desired_index}"

    desired=$(get_by_index "${systems}" "${desired_index}")

    case ${status} in
    0) items_menu "${desired}" ;;
    1) main_menu ;;
    *) exit 1 ;;
    esac
}

items_menu() {
    local system
    local system_name
    local system_id
    local items_cache_path
    local items_cache
    local items
    local cmd
    local options
    local item_options
    local index
    local item_option
    local desired_index
    local status
    local desired

    system=$1

    system_name=$(
        echo "${system}" |
            jq -r .name
    )
    log "Selected: ${system_name}"

    system_id=$(
        echo "${system}" |
            jq -r .id
    )

    items_cache_path="${base_cache}/${system_id}"
    mkdir -p "${items_cache_path}"
    items_cache="${items_cache_path}/items.json"
    if [[ -f "$items_cache" ]]; then
        log "Reading items for ${system_name} from cache: ${items_cache}"
        items=$(cat "${items_cache}")
    else
        dialog --infobox "Loading items for ${system_name}, please wait..." 5 50 2>&1 >/dev/tty1
        items=$(search_system "${systems}" "${system}")
        echo "${items}" >"${items_cache}"
    fi

    cmd=(dialog --cancel-label "Back" --backtitle "Pick an item" --title " [ Items Menu ] " --menu "D-pad to move, A or B to select" "15" "75" "15")
    options=()

    item_options=$(
        echo "${items}" |
            jq -r .[].title
    )
    index=0
    while read -r item_option; do
        options+=($((index++)) "${item_option}")
    done <<<"${item_options}"

    desired_index=$("${cmd[@]}" "${options[@]}" 2>&1 >/dev/tty1)
    status=$?
    log "Status: ${status}, Desired index: ${desired_index}"

    desired=$(get_by_index "${items}" "${desired_index}")

    case ${status} in
    0) files_menu "${system}" "${desired}" ;;
    1) systems_menu ;;
    *) exit 1 ;;
    esac
}

files_menu() {
    local system
    local item
    local item_name
    local system_id
    local item_id
    local files_cache_path
    local files_cache
    local files
    local cmd
    local options
    local file_options
    local index
    local file_option
    local file_option_readable
    local desired_index
    local status
    local desired

    system=$1
    item=$2

    item_name=$(
        echo "${item}" |
            jq -r .title
    )
    log "Selected: ${item_name}"

    system_id=$(
        echo "${system}" |
            jq -r .id
    )
    item_id=$(
        echo "${item}" |
            jq -r .identifier
    )

    files_cache_path="${base_cache}/${system_id}/${item_id}"
    mkdir -p "${files_cache_path}"
    files_cache="${files_cache_path}/files.json"
    if [[ -f "$files_cache" ]]; then
        log "Reading files for ${item_name} from cache: ${files_cache}"
        files=$(cat "${files_cache}")
    else
        dialog --infobox "Loading files for ${item_name}, please wait..." 5 50 2>&1 >/dev/tty1
        files=$(list_files "${system}" "${item}")
        echo "${files}" >"${files_cache}"
    fi

    cmd=(dialog --cancel-label "Back" --backtitle "Pick a file" --title " [ Files Menu ] " --menu "D-pad to move, A or B to select" "15" "75" "15")
    options=()

    file_options=$(
        echo "${files}" |
            jq -r .[].name
    )
    index=0
    while read -r file_option; do
        file_option_readable=$(urldecode "${file_option}")
        options+=($((index++)) "${file_option_readable}")
    done <<<"${file_options}"

    desired_index=$("${cmd[@]}" "${options[@]}" 2>&1 >/dev/tty1)
    status=$?
    log "Status: ${status}, Desired index: ${desired_index}"

    desired=$(get_by_index "${files}" "${desired_index}")

    case ${status} in
    0) file_screen "${system}" "${item}" "${desired}" ;;
    1) items_menu "${system}" ;;
    *) exit 1 ;;
    esac
}

file_screen() {
    local system
    local item
    local file
    local file_name
    local file_name_readable
    local file_size
    local file_size_readable
    local extra
    local status

    system=$1
    item=$2
    file=$3

    file_name=$(
        echo "${file}" |
            jq -r .name
    )
    file_name_readable=$(urldecode "${file_name}")
    log "Selected: ${file_name_readable}"

    file_size=$(
        echo "${file}" |
            jq -r .size
    )
    file_size_readable=$(human_readable "${file_size}")

    # Archive.org only provides sub file navigation for archive files.
    extra=()
    if [[ $file_name == *.zip || $file_name == *.7z ]]; then
        extra=("--extra-button" "--extra-label" "Open")
    fi

    dialog --backtitle "Pick an action" --title " [ File Information ] " --yes-label "Download" --ok-label "Download" --no-label "Back" --cancel-label "Back" "${extra[@]}" --yesno "File Name: ${file_name_readable}\nSize: ${file_size_readable}" 15 50 2>&1 >/dev/tty1
    status=$?
    log "Status: ${status}"

    case ${status} in
    0) download_screen "${system}" "${item}" "${file}" ;;
    1) files_menu "${system}" "${item}" ;;
    3) open_file_screen "${system}" "${item}" "${file}" ;;
    *) exit 1 ;;
    esac
}

open_file_screen() {
    local system
    local item
    local file
    local file_name
    local file_name_readable
    local system_id
    local item_id
    local sub_files_cache_path
    local sub_files_cache
    local sub_files
    local cmd
    local options
    local sub_file_options
    local sub_file_option_readable
    local index
    local sub_file_option
    local desired_index
    local status
    local desired

    system=$1
    item=$2
    file=$3

    file_name=$(
        echo "${file}" |
            jq -r .name
    )
    file_name_readable=$(urldecode "${file_name}")
    log "Selected: ${file_name_readable}"

    system_id=$(
        echo "${system}" |
            jq -r .id
    )
    item_id=$(
        echo "${item}" |
            jq -r .identifier
    )

    sub_files_cache_path="${base_cache}/${system_id}/${item_id}/${file_name_readable}"
    mkdir -p "${sub_files_cache_path}"
    sub_files_cache="${sub_files_cache_path}/sub_files.json"
    if [[ -f "$sub_files_cache" ]]; then
        log "Reading files for ${item_name} from cache: ${sub_files_cache}"
        sub_files=$(cat "${sub_files_cache}")
    else
        dialog --infobox "Loading sub files for ${file_name_readable}, please wait..." 5 50 2>&1 >/dev/tty1
        sub_files=$(list_sub_files "${system}" "${item}" "${file}")
        echo "${files}" >"${sub_files_cache}"
    fi

    cmd=(dialog --cancel-label "Back" --backtitle "Pick a sub file" --title " [ Files Menu ] " --menu "D-pad to move, A or B to select" "15" "75" "15")
    options=()

    sub_file_options=$(
        echo "${sub_files}" |
            jq -r .[].name
    )
    index=0
    while read -r sub_file_option; do
        sub_file_option_readable=$(urldecode "${sub_file_option}")
        options+=($((index++)) "${sub_file_option_readable}")
    done <<<"${sub_file_options}"

    desired_index=$("${cmd[@]}" "${options[@]}" 2>&1 >/dev/tty1)
    status=$?
    log "Status: ${status}, Desired index: ${desired_index}"

    desired=$(get_by_index "${sub_files}" "${desired_index}")

    case ${status} in
    0) file_screen "${system}" "${item}" "${desired}" true ;;
    1) files_menu "${system}" "${item}" ;;
    *) exit 1 ;;
    esac
}

download_screen() {
    local system
    local item
    local file
    local file_name
    local file_name_readable
    local base_file_name
    local system_path
    local download_path

    system=$1
    item=$2
    file=$3

    file_name=$(
        echo "${file}" |
            jq -r .name
    )
    log "Selected: ${file_name}"

    # When we download a file named foo/bar/baz.zip, we want to emplace it at
    # ${path}/baz.zip, stripping off the foo/bar part.
    file_name_readable=$(urldecode "${file_name}")
    base_file_name=$(basename "${file_name_readable}")

    system_path=$(echo "${system}" |
        jq -r .path)
    download_path="${base_path}/${system_path}/${base_file_name}"

    download_file "${item}" "${file}" "${download_path}" | dialog --gauge "Downloading ${file_name}, please wait..." 7 75 0 2>&1 >/dev/tty1

    downloaded_screen "${system}" "${item}" "${file}" "${download_path}"
}

downloaded_screen() {
    local system
    local item
    local file
    local download_path
    local file_name
    local status

    system=$1
    item=$2
    file=$3
    download_path=$4

    file_name=$(
        echo "${file}" |
            jq -r .name
    )
    log "Downloaded: ${file_name}"

    dialog --backtitle "Download complete" --title " [ ${base_file_name} ] " --yesno "The selected file has been downloaded to ${download_path}. Do you want to exit so you can play it now?" 15 50 2>&1 >/dev/tty1
    status=$?
    log "Status: ${status}"

    case ${status} in
    0) exit 0 ;;
    1) files_menu "${system}" "${item}" ;;
    *) exit 1 ;;
    esac
}

stop() {
    log "Stopping RomMaster"

    $sudo_prefix pkill tm-joypad >/dev/null 2>&1

    if [[ $(systemctl is-active emulationstation.service) = "active" ]]; then
        ${sudo_prefix} systemctl restart emulationstation
    fi
    if [[ $(systemctl is-active emustation.service) = "active" ]]; then
        ${sudo_prefix} systemctl restart emustation
    fi

    clear >/dev/tty1
}

clear
trap stop EXIT
start
